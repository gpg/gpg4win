#! /bin/sh
patch -p1 -f -l $* < $0
exit $?

From 4b98e52ca0227831fe40c9508a4b5945e4d5e2be Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ingo=20Kl=C3=B6cker?= <dev@ingo-kloecker.de>
Date: Thu, 25 Sep 2025 16:20:07 +0200
Subject: [PATCH 1/2] Send accessible state change event after window was made
 active

QGuiApplicationPrivate::processFocusWindowEvent is called when a new
dialog is opened or when the active window is changed by the user (at
least on Windows). This function sends FocusOut and FocusIn events to
the QWindows *before* calling notifyActiveWindowChange which makes the
new window the active window. Therefore, on Windows, the accessible state
change event did send a Window_WindowOpened and an AutomationFocusChanged
(instead of a Window_WindowClosed) event for the *old* window. This
confuses accessibility tools.

Sending the accessible state change events on WindowActivate and
WindowDeactivate ensures that the correct window is marked as active
window when QWindowsUiaMainProvider checks the active state of the
event object.

Change-Id: I5e87d032289655ef160ecea0ab3a56ed0aaac347
---
 src/widgets/kernel/qwidgetwindow.cpp | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/widgets/kernel/qwidgetwindow.cpp b/src/widgets/kernel/qwidgetwindow.cpp
index 737ccb0e807..175bc3b0d67 100644
--- a/src/widgets/kernel/qwidgetwindow.cpp
+++ b/src/widgets/kernel/qwidgetwindow.cpp
@@ -234,15 +234,19 @@ bool QWidgetWindow::event(QEvent *event)
     // are sent by QApplicationPrivate::notifyActiveWindowChange()
     case QEvent::FocusIn:
         handleFocusInEvent(static_cast<QFocusEvent *>(event));
-        Q_FALLTHROUGH();
-    case QEvent::FocusOut: {
+        return false;
+    case QEvent::FocusOut:
+        return false;
+
+    case QEvent::WindowActivate:
+    case QEvent::WindowDeactivate: {
 #if QT_CONFIG(accessibility)
         QAccessible::State state;
         state.active = true;
         QAccessibleStateChangeEvent ev(m_widget, state);
         QAccessible::updateAccessibility(&ev);
 #endif
-        return false; }
+        break; }

     case QEvent::FocusAboutToChange:
         if (QApplicationPrivate::focus_widget) {
--
2.51.0

From a57eb8598cc2d0240437354e1f9c5ca200bd1c50 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ingo=20Kl=C3=B6cker?= <dev@ingo-kloecker.de>
Date: Thu, 25 Sep 2025 16:32:18 +0200
Subject: [PATCH 2/2] Ensure that window activation events are send to
 QWidgetWindows

Contrary to the removed comment QApplication::setActiveWindow() does not
send window activation events to the QWidgetWindows but only to the
QWidgets associated with the QWidgetWindows. Removing the special code
and calling the base class ensures that window activation events are
also send to QWidgetWindows.

Change-Id: I7acf2cfcbab693752fe6c04ab73506bd4477912b
---
 src/widgets/kernel/qapplication.cpp | 15 +--------------
 1 file changed, 1 insertion(+), 14 deletions(-)

diff --git a/src/widgets/kernel/qapplication.cpp b/src/widgets/kernel/qapplication.cpp
index 1a0c2a047f2..5baf059999c 100644
--- a/src/widgets/kernel/qapplication.cpp
+++ b/src/widgets/kernel/qapplication.cpp
@@ -1942,20 +1942,7 @@ void QApplicationPrivate::notifyActiveWindowChange(QWindow *previous)
                     widget->setFocus(Qt::ActiveWindowFocusReason);
     }

-    // QApplication::setActiveWindow() will deliver window activation events for
-    // QWidgetWindows. But for other subclasses of QWindow (like QQuickWindow), we
-    // need to send them explicitly, like we do from the base class implementation.
-    if (previous && !qobject_cast<QWidgetWindow *>(previous)) {
-        QEvent de(QEvent::WindowDeactivate);
-        QCoreApplication::sendEvent(previous, &de);
-    }
-
-    if (focusWindow && !qobject_cast<QWidgetWindow *>(focusWindow)) {
-        QEvent ae(QEvent::WindowActivate);
-        QCoreApplication::sendEvent(focusWindow, &ae);
-    }
-
-    // don't call base class to avoid double delivery of WindowActivate/Deactivate events
+    QGuiApplicationPrivate::notifyActiveWindowChange(previous);
 }

 /*!internal
--
2.51.0
